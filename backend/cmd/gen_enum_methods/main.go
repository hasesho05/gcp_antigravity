package main

import (
	"bytes"
	"flag"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"log"
	"os"
	"strings"
	"text/template"
)

var (
	typeNames = flag.String("type", "", "comma-separated list of type names; must be set")
	output    = flag.String("output", "", "output file name; default srcdir/<type>_enumer.go")
)

func main() {
	flag.Parse()

	// We assume we are running in the directory of the package
	dir, err := os.Getwd()
	if err != nil {
		log.Fatal(err)
	}

	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, dir, nil, parser.ParseComments)
	if err != nil {
		log.Fatal(err)
	}

	for _, pkg := range pkgs {
		// If types are specified via flag, use them
		if *typeNames != "" {
			types := strings.Split(*typeNames, ",")
			for _, typeName := range types {
				values := extractValues(pkg, typeName)
				if len(values) == 0 {
					continue
				}
				generateFile(typeName, pkg.Name, values)
			}
		} else {
			// Auto-detect types with // tygo:enum comment
			detectedTypes := detectEnumTypes(pkg)
			for typeName, values := range detectedTypes {
				generateFile(typeName, pkg.Name, values)
			}
		}
	}
}

func detectEnumTypes(pkg *ast.Package) map[string][]string {
	results := make(map[string][]string)
	
	// First pass: find types marked with // tygo:enum
	targetTypes := make(map[string]bool)

	for _, file := range pkg.Files {
		ast.Inspect(file, func(n ast.Node) bool {
			decl, ok := n.(*ast.GenDecl)
			if !ok {
				return true
			}
			
			// Check for type definitions
			if decl.Tok == token.TYPE {
				for _, spec := range decl.Specs {
					typeSpec := spec.(*ast.TypeSpec)
					// Check doc comments on the type definition
					if (decl.Doc != nil && containsTygoEnum(decl.Doc.List)) || 
					   (typeSpec.Doc != nil && containsTygoEnum(typeSpec.Doc.List)) {
						targetTypes[typeSpec.Name.Name] = true
					}
				}
			}
			// Check for const blocks with the comment (as seen in user.go)
			if decl.Tok == token.CONST {
				if decl.Doc != nil && containsTygoEnum(decl.Doc.List) {
					// If the const block is marked, we need to find the type of the constants
					for _, spec := range decl.Specs {
						vspec := spec.(*ast.ValueSpec)
						if vspec.Type != nil {
							if ident, ok := vspec.Type.(*ast.Ident); ok {
								targetTypes[ident.Name] = true
							}
						}
					}
				}
			}
			return true
		})
	}

	// Second pass: extract values for identified types
	for typeName := range targetTypes {
		values := extractValues(pkg, typeName)
		if len(values) > 0 {
			results[typeName] = values
		}
	}
	
	return results
}

func containsTygoEnum(comments []*ast.Comment) bool {
	for _, c := range comments {
		if strings.Contains(c.Text, "tygo:enum") {
			return true
		}
	}
	return false
}

func extractValues(pkg *ast.Package, typeName string) []string {
	var values []string
	for _, file := range pkg.Files {
		ast.Inspect(file, func(n ast.Node) bool {
			decl, ok := n.(*ast.GenDecl)
			if !ok || decl.Tok != token.CONST {
				return true
			}
			for _, spec := range decl.Specs {
				vspec := spec.(*ast.ValueSpec)
				if vspec.Type == nil {
					continue
				}
				ident, ok := vspec.Type.(*ast.Ident)
				if !ok || ident.Name != typeName {
					continue
				}
				for _, value := range vspec.Values {
					lit, ok := value.(*ast.BasicLit)
					if ok && lit.Kind == token.STRING {
						values = append(values, strings.Trim(lit.Value, "\""))
					}
				}
			}
			return true
		})
	}
	return values
}

const enumTemplate = `// Code generated by go run scripts/gen_enum_methods.go; DO NOT EDIT.
package {{.Package}}

func ({{.Type}}) Values() []string {
	return []string{
{{- range .Values }}
		"{{.}}",
{{- end }}
	}
}

func {{.Type}}Values() []{{.Type}} {
	return []{{.Type}}{
{{- range .Values }}
		"{{.}}",
{{- end }}
	}
}
`

func generateFile(typeName, pkgName string, values []string) {
	filename := *output
	if filename == "" {
		filename = strings.ToLower(typeName) + "_enumer.go"
	}

	f, err := os.Create(filename)
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	tmpl, err := template.New("enum").Parse(enumTemplate)
	if err != nil {
		log.Fatal(err)
	}

	var buf bytes.Buffer
	err = tmpl.Execute(&buf, struct {
		Package string
		Type    string
		Values  []string
	}{
		Package: pkgName,
		Type:    typeName,
		Values:  values,
	})
	if err != nil {
		log.Fatal(err)
	}

	src, err := format.Source(buf.Bytes())
	if err != nil {
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
		src = buf.Bytes()
	}

	f.Write(src)
}
